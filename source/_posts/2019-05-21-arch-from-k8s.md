---
layout: post
title: 从 k8s 看架构
category: 技术
keywords: golang,k8s,docker,微服务,后端
comments: false
---

k8s 解决了服务治理，而 docker 解决了资源隔离。
所以我所认为 k8s 解决的问题从宏观上看，就是开发效率与资源利用率。

当然这个只是 k8s 作为方法，向上所解决的问题域，那我们要重点看的是以 k8s 作为问题域的入口，他解决了什么问题，以及他是如何解决这个问题的。

综合最近对问题域的探索，我觉得可以沿着这样一个路径去探究一个大问题的问题树：

* 问题->发散到问题->映射到方法->收敛到资源

## 第一层问题域

我觉得清晰了问题域，很自然而然就能明白他的代码为什么这么写。而不是捧着源码半天不知道写的啥，昏昏欲睡然后打开了 bilibili...

问题域是你的知识框架，技术解决的是实际问题，所以技术架构是解决问题的索引。

<!--more-->

### 服务



### 资源

分布式系统将离散的资源，再次组合成为了一个整体的资源。

1. 物理资源为基础，比如 CPU、内存、带宽等。

2. 建立于物理资源之上的软件资源，比如调用物理资源的接口。

3. 软件构成 Paas 之后的不同排列组合的 复合资源（Pod\Service\ReplicSet\DaemonSet...）。

复合资源是一种服务理想状态的抽象。
我有好多模板，模板里有语法描述了服务的规格，期望的状态。
这样的模板对于系统来说就是一种资源，有点像图灵机。

每一种都是上一层的抽象，所以对于 K8s 来说，资源的问题其实是
对*离散资源的抽象*。

### 通信

离散的节点需要有一个高效的通信模式，这个通信模式基于我们预先设置的网络架构。

通信对我们而言是双向的，既要对外又要对内。同时，*容器与容器*、*组件与组件*。

所以对于通信而言，

1. 要有好的网络层架构
2. 要有满足不同情况的传输的通道，或者说接口

#### 客户端与容器

Service 类型

#### 容器与容器



#### 组件与组件

ApiServer

#### 客户端与组件

ApiServer


### 数据

数据的问题理解，相对简单，我们要解决的其实是如何存储数据，并且能够保证数据在分布式系统中的某些特性。

所以我们可以理解为 *存哪儿* 的问题。

## 第二层转化

* Pod 本身就具有优先等级，称为 QoS，用来给调度器做调度优先级排序。主要作用是当宿主机资源紧张的时候，资源回收时候的优先级依据。
我们可以聚焦下调度器本身。

调度器调用位置：
github.com/kubernetes/kubernetes/pkg/scheduler/scheduler.go:scheduleOne

调度器源码实现位置：
github.com/kubernetes/kubernetes/pkg/scheduler/core/generic_scheduler.go

- Schedule // 优先式调度
    尝试调度 Pod 到某个 node，成功返回 podName，
    先 `predicates` 对 符合条件的 nodes 做过滤，不排序
    再 `prioritize` nodes，给服筛选出来的 nodes 打分。
    然后在合适的 nodes 中 Round-robin 出来一个最合适的 host，这个过程称为 `selecting host`。

- Preempt(抢占) // 如果优先调度没有找到节点，那就只能抢占式调度了
    抢占式调度精髓，就是把低优先级的丢掉。

- Predicates(暴露接口仅供测试)
- Prioritizers(暴露接口仅供测试)
  
同时，在做调度的时候 K8s 提供亲和度选项，用来控制部分节点的选择，这个属于 predicates 阶段。
但有个问题是在 prioritize 阶段会有堆叠问题。