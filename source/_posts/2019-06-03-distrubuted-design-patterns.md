---
layout: post
title: 分布式系统设计模式
category: 技术
keywords: 架构,分布式,微服务,后端,分布式系统,设计模式
comments:  true
---

## 概述

这篇文章是对于[【分布式系统设计模式】](https://www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf)的个人理解和部分翻译。

文章探讨了关于《基于容器化软件组件的微服务架构》。

其实容器化编程的发展路径和面向对象编程有异曲同工之妙--
都是将复杂的系统进行抽象、解耦，然后通过一定的方式组合起来。

既然我们要组合，肯定会有面对不同情况的不同组合方式。所以，这些不同的组合方式也会有几个常用的固定模式。
而这个正式我们要探讨的--分布式系统设计模式。

说到分布式，第一个联想到的应该就的容器化。
为什么？其实容器化和分布式本没有交集，只是因为我们发现容器化是一个实现分布式的高效的方法。

容器化设置了一个天然的边界，边界之外用接口进行通信。
有了这个边界的好处就是，任何意料之外的情况都可以被限制在最小的影响范围，毕竟我们构建的是一个大型的复杂系统。

我认为，用[FMEA](https://zh.wikipedia.org/wiki/%E5%A4%B1%E6%95%88%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BD%B1%E5%93%8D%E5%88%86%E6%9E%90)模型能很好的描述为什么会采用容器化去解构分布式系统。(FMEA，可以理解为：失控的状态一定会发生，我们要做的是控制失控的范围)

所以，我们接下来要说的设计模式基本上都是和容器相关。

## 单容器管理者模式 (Single-container management patterns)

能够让容器互联互通的一个主要原因是广泛的 http 协议支持，你完全可以通过 http 和 JSON这样的序列化方式去构造你应用的对外的 API。

一般来说我们的设计方针都是一个容器提供一种服务。同时容器会为其上下游提供接口。

什么接口？

向上，提供容器本身丰富的信息接口。能够为特定的监控容器运行状态的应用提供信息。

向下，提供了控制容器本身的接口。使得分布式系统能够更有效的管理整个应用的生命周期，以及应用的优先级。
比如，一个集群的管理系统，能够设置集群处理任务的优先级。（比如 K8s 中的抢占式调度）

## 单节点-多容器应用模式 (Single-node, multi-container application patterns)

这种模式比较好理解，有些容器应用是需要“共生”的，所以我们会将其放在同一个节点上。
一旦这样，分布式系统会对容器组做联合调度。
比如 K8s 里将调度单位描述成了 Pods（一个 Pod 可能包含多个容器），Nomad 则称其为 task groups。
下面几个就是常用的单节点多容器的设计模式：

### 副载模式（Sidecar pattern）

多容器部署最通用的一种模式，就是 sidecar 模式。
其实大家都直接称呼 Sidecar 模式，不会翻译成副载。

那 Sidecar 是个啥样子呢？

举个例子吧：我们有一个主容器是 Web Server，我们需要收集 Web Server 所产生的日志。
所以我们会有一个专门的 sidecar 容器，负责收集日志并把日志存储到集群的存储系统。
![0](../assets/img/dp/dp1.png)

另外一个例子，就是主容器的内容呈现，是由一个 sidecar 容器去实时同步的。

还有个例子是为一个 Http Web Server 提供 Https 功能。

![1](../assets/img/dp/ssl-termination-proxy-sidecar.svg)

你会发现 Sidecar 是主容器的一种扩展和升级，这种模式的好处在于，因为是容器隔离，所以能够保证从属容器不会在主容器需要资源的时候占用过多的资源，因为分配资源的最小单位就是容器。同时，sidecar 一般在功能上比较专职，又是容器化的，所以可以很方便的进行单独的部署、升级。

### 大使模式（Ambassador pattern）

![abd](../assets/img/dp/abdor.jpg)

大使模式实现方式是在节点中增加一个通讯代理。他解决的问题是：
为某些年久失修的外部服务，增加一个调用代理，调用者是我们节点上的应用。

大使模式给开发者的好处是：

1. 他们只要考虑应用与本地服务的连接
2. 他们可以在本地进行测试
3. 调用的外部服务语言无关

其实有个很典型但是非容器化的例子，就是 Ribbon 中的客户端负载。
和大使模式很像，所有的请求流量都先经由客户端的负载均衡器决定了流量流向--我们在大使容器中现决定流量流向，然后直接调用真正的服务。

聪明的你会发现，我们似乎可以在大使容器中做很多手脚，比如熔断，路由，流量监控，安全控制等等（有点像服务端的 API 网关）。

没错，所以我们得出了一些使用该模式的场景（来自https://docs.microsoft.com/en-us/azure/architecture/patterns/ambassador）:

- 客户端连接语言无关，框架无关
- 将客户端连接的问题与应用分离，解耦开发
- 为年久失修的应用程序提供云或集群支持

### 适配器模式（Adapter pattern）

和 Ambassador 相比，Adapter 模式向外部呈现了一个统一的接口。（方向反了一下）

最典型的例子应该就是容器管理平台，所有系统中的容器都会有一套统一的监控接口。

现在的容器多种多样，不过只要保证每个容器都有统一的不变的对外监控接口，对于单独的监控工具来说就不难实时收集各个容器的数据了。

单节点多容器的模式主要就是上面三种。

## 多节点应用模式 (Multi-node application patterns)

和单节点多应用模式一样，我们同样要求实现这个模式的系统支持  K8s 中 Pod 这样的概念。

### 领导人选举 (Leader election pattern)

在分布式系统中，老生常谈的问题了，就是领导人选举。

一般领导人选择是怎样一种状态呢？就是在分布式系统中，存在一个或者多个领导人，还有剩下的作为工作节点。
一旦有领导人节点挂了，工作节点按照一定算法升级成为领导人节点。

领导人选举算法是十分复杂的算法（至少对我来说），甚至有些算法库还是语言限定的，所以，更好的方式就是通过容器去使用这个领导人选举功能。

那为什么要分为领导节点和工作节点呢？

当然是为了更好分配任务，分配好了任务，就能保证系统处在一个高效的状态下运行。避免出现有些工作节点空闲，有些工作节点忙的现象。整个模式的思想还是中心化治理最高效的方针。

### 工作队列模式 (Work queue pattern)

我觉得，分布式系统中的工作队列模式，其实表达了一个具有拓扑关系的分布式系统。每个步骤都是单独的，但是他们的输入可能需要依靠上一个输出，亦或者，他们的输出会成为下一个的输入。

但是等等，这个应该更靠近业务架构呀，工作队列模式真的是这样吗?

### 向量化模式 (Scatter/gather pattern)

## 总结

所以，我们可以看到，一般分布式系统中会有上面 7 种模式。
注意，上面这 7 中模式会以组合的形式出现在分布式系统之中，毕竟分布式系统是一个复杂系统。

第二点，就是我们所理解的开发解耦。不同的组件开发团队甚至在开发初级阶段不需要过多的联调。

第三是可复用性增强，因为功能单一化+容器化，想加一个删一个都很容易。

第四是错误边界固定，sidecar 模式的容器出现的错误不会影响主容器的运行。

