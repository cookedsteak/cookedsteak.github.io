---
layout: post
title: Golang 内存模型
category: 技术
keywords:  golang,go,内存,后端
comments: false
---

## 开头

为什么会看到内存模型呢？
主要是这几天在整理微服务架构的一些知识点，其中一个并发分支中有内存模型这个子分支。
所以就好奇翻看了内存模型和并发性能之间的关系。

内存模型（Memory Model），这是一个贯穿高级编程语言，编译器，处理器综合性问题。

<!--more-->

## 我要程序跑的快

都9012年了，技术突飞猛进，编译优化技术和CPU执行优化技术提高了我们程序指令的执行速度。我们先来看看，如果我要我程序跑得快，这两种技术是怎么起到助推作用的。

### 编译优化

我们知道，我们所写的程序会被编译器编译为计算机的可执行代码，或者是解释器、虚拟机的可执行代码。
我们会在编写程序的时候就尽可能优化我们的代码，但其实我们的优化站在计算机的角度并不完全。所以
编译器会在代码基础上进行重排序（instruction reordering）。
那重排序的依据是什么呢？如何保证重排序后执行结果还是正确的呢？
其中一个依据就是数据依赖：

```c
a = 1; b = a; #1
a = 1; a = 2; #2
a = b; b = 1; #3
```

其实就是运行代码的前后依赖关系，上面的三种赋值操作，只要改变其中一个的前后顺序，得到的结果就会不一样。
所以，编译器会根据数据依赖性，来重排序。

### CPU执行优化

- 乱序执行

基本上现有 CPU 的指令运行都是乱序执行的。
什么是乱序，就是 CPU 判读你的前后两个指令并不连续相关，那么他就会议选择并行执行这两个指令。

这是保证 CPU 高效运行的基础。

- CPU缓存

CPU会有自己的缓存，缓存为了提高CPU运作执行效率。
缓存中的数据来自内存，但是，CPU 缓存与内存之间是存在时间差的，所以可能导致两遍的数据不一致。那CPU在使用缓存数据的时候有一个标准，就是只有内存和缓存中的数据一致，那才会使用缓存中的数据提高执行速度。


## 快了，然后呢

没错，我们通过编译优化和CPU执行优化提高了程序的执行速度，但是准确性呢？

我们上面的字里行间似乎没有提到内存什么事儿，但是程序的执行和数据都是存内存里来的呀。我们也知道，内存到CPU执行中间可有一条很长的线路呢，导致可能传输到CPU执行的时候，其实内存中的数据以及被改变了，数据产生了错误，计算结果也产生错误。

## 内存模型

所以这时候就要让【合理的】内存模型来解决我们遇到的问题了。
我们再来整理下我们遇到的问题：
1. 限制过度的编译优化和直连并行优化
2. 线程之间对内存的操作能够互相知晓，保证计算结果正确

好了，现在我们知道要【合理】，那到底是怎么个合理法？我们需要建立在一定的语言基础上，所以我们以golang为例，看一下golang的内存模型是怎么设计的。




## 参考

- <http://valleylord.github.io/post/201606-memory-model/>
- <https://www.zhihu.com/question/36293510>
- <https://blog.csdn.net/beiyetengqing/article/details/49580559>
- <https://golang.org/ref/mem>
- <https://tiancaiamao.gitbooks.io/go-internals/content/zh/10.1.html>
