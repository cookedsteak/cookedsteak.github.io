---
layout: post
title: Golang 内存模型
category: 技术
keywords:  golang,go,内存,后端
comments: false
---

## 开头

为什么会看到内存模型呢？
主要是这几天在整理微服务架构的一些知识点，其中一个并发分支中有内存模型这个子分支。
所以就好奇翻看了内存模型和并发性能之间的关系。

内存模型（Memory Model），这是一个贯穿高级编程语言，编译器，处理器综合性问题。

<!--more-->

## 和编译器有关的重排序

我们知道，我们所写的程序会被编译器编译为计算机的可执行代码，或者是解释器、虚拟机的可执行代码。
我们会在编写程序的时候就尽可能优化我们的代码，但其实我们的优化站在计算机的角度并不完全。所以
编译器会在代码基础上进行重排序（instruction reordering）。
那重排序的依据是什么呢？如何保证重排序后执行结果还是正确的呢？
其中一个依据就是数据依赖：

```c
a = 1; b = a; #1
a = 1; a = 2; #2
a = b; b = 1; #3
```

其实就是运行代码的前后依赖关系，上面的三种赋值操作，只要改变其中一个的前后顺序，得到的结果就会不一样。
所以，编译器会根据数据依赖性，来重排序。

## 和 CPU 有关

### 乱序执行

基本上现有 CPU 的指令运行都是乱序执行的。
什么是乱序，就是 CPU 判读你的前后两个指令并不连续相关，那么他就会议选择并行执行这两个指令。

这是保证 CPU 高效运行的基础。

### 缓存与内存

CPU 缓存与内存之间是存在时间差的，所以可能导致两遍的数据不一致。
一般 CPU 都会有自己的数据读取策略保证一致性。

## 内存模型

内存模型是一个解决问题的模型，那解决的是什么问题呢？
在多线程情况下，可能存在

内存产生的问题，归根结底是多线程并发过程中的问题。
多线程编程模型有两种

1. 内存共享
2. 消息传递

消息传递呢又会有两个并发模型：

1. Actor
2. CSP

而 CSP 就是 Golang 所采用的并发模型。

## 参考

- <http://valleylord.github.io/post/201606-memory-model/>
- <https://www.zhihu.com/question/36293510>
- <https://blog.csdn.net/beiyetengqing/article/details/49580559>
- <https://golang.org/ref/mem>
