---
layout: post
title: 怪谈面向对象设计模式-上
category: 技术
keywords: 设计模式,golang,架构,微服务,后端,设计,模式
comments:  true
---

## 前言


## 模式的种类

23种设计模式，也是有分类的，模式的分类分别聚焦于一下三个问题：

1. 我怎么创建一个对象？
2. 对象与对象之间怎么调用？
3. 对象和算法之间如何协调解决问题？

## 建造者模式 创建 Builder Pattern

对象的复杂度是会变化的，面对复杂对象的创建，我们急需将创建的过程统一管理起来，以避免后期维护的额外成本。
这也就是面向对象设计模式中，创建型模式的初衷。建造者模式作为创建型设计模式的一种，其核心是将对象的生产顺序交给一个
单独的类进行控制，以满足生产准备工作的依赖问题。但是，这个模式只适用于生产结构相似的对象，不适合建造差异较大的对象。


比较对象：工厂模式

- 相同点：

1. 都是将具体实现对象的方法给解耦了，所以都会有单独的对象实现（法）类。
工厂中我们看到的是“抽象工厂”，建造者模式中我们看到的是“Builder”。

1. 工厂模式和建造者模式都不会对外暴露任何生产的细节


- 不同点：

1. 在创建过程中，工厂模式不允许调用者控制建造的细节（顺序），只存在造与不造。
2. 建造者模式中除了用`Builder`将复杂的创建过程封装起来外，还额外提供了建造顺序的可控，除了造与不造，你还能决定怎么造。


## 原型模式 创建 Prototype Pattern

如果需要生产多个复杂对象的话，进行对象的复制是最快的。
所以我们才有了原型模式这样的创建型模式。
其核心是克隆现有对象和对象的状态。

这种方式其实在微服务治理上也有很广泛的应用。
比如一些服务的迁移和重启，为了保证无缝，会保证原始服务的状态。

## 桥接模式 Bridge Pattern

桥接模式核心是减少重复的子类，用不同角度的抽象解决问题。

一个桥接模式的设计思路是：抽象中的抽象，也有人会描述为抽象与具现

什么是抽象中的抽象？

举个例子：
一个手机会有手机的抽象（形状，配置），手机会有`震动`功能，这个功能对于不同手机可能不一样，有的是快速震动，有的是缓慢震动。
那，如果我们需要创建一个有震动功能的手机会怎么创建呢？

很简单吧，工厂模式。
但是思考一下，如果我用工厂模式，是不是我要同时判断好几个参数，并且制定好几个子类。
所以，如果用抽象思维去解决，我们在抽象出手机的组成后，再抽象出震动功能的抽象类，放置到手机抽象类中，
是不是就可以解决了呢？

伪代码如下
```
class abstract Phone {
    class abstract ShakeFunction {
        function HighShake()
        function LowShake()
    }
    Shape
    Configuration
}
```

一旦按照这样的抽象方式去实现，就可以具象分离了。
我可以单独实现 ShakeFunction，然后实现 Phone。
然后把他们两个结合起来。

而上面就是典型的桥接器。

是不是比工厂方便抽象多了！

-适配器模式与桥接器模式的联用-

适配器模式就是一个典型的中间件。
适配器用自己的方式包装一个适配者。

## 组合模式 Composite Pattern

如果说，桥接模式是对象与对象方法（功能）的抽象-剥离和具现-结合，那么
组合模式，就是对象与对象的抽象-剥离和具现-结合。

组合元素的核心就是去重，去除一些冗余的对象的重复实现。
并且我们能够任意组合被我们分割的子对象。

比如，A公司有产品经理、UI、程序员，B公司有产品经理、UI、程序员。

那组合模式下，就是公司管公司一类，产品经理、UI、程序员各位三类。

## 享元模式 Flyweight Pattern

又是一个解决对象数量太多的问题的设计模式，
顾名思义，共享同一个元对象。

该模式核心在于他有一个工厂类，工厂类的作用在于提供储存元对象的享元池。
就是对象的复用。那问题就来了，他与单例模式有什么区别呢？

单例模式只创建一个，因为你只需要一个一样的。
享元模式可能需要好多个，因为好多个都处于不同的状态，但是每种状态只需要一个就够了。

举个简单的例子，数据源你可能只要一个，但是连接不同种类数据库的你需要好几个，但是每种也只要一个就够了。


## 状态模式 State Pattern 行为模式

现在到了行为模式的解析了，行为模式是表述对象和方法、算法之间的关系。

对于状态模式的官方解释其实挺容易理解，就是行为跟着对象的状态改变而改变。
举个例子，一个订单可能有好几种状态，创建状态，和发货状态。
那我们就拿每个状态作为一个子类。

但是订单本身的操作是可以归结的。

其实也有点像桥接模式，状态是一种抽象，对象本身的行为也是一种抽象（只不过根据状态具体的实现方式会不一样）

为什么要用状态模式，我觉得是在可读性和复合闭包的课扩展性上做了着重。

如果一个对象会有很多状态，不同的状态对应不同的操作，那么最传统的方式是用`switch`。

可能会像如下代码一样：
```
class Order {

    function A {
        switch xx {
            case 1:
            case 2:
            ...
        }
    }

    function B {
        switch xx {
            case 1:
            case 2:
            ...
        }
    }

}
```

如果状态很多，或者状态需要继续添加变更，switch 的模式会非常麻烦。
为了方便管理，以及代码的可读性，就会用到状态模式。

其实代码量并没有减少，反而是增加的，但是把每个状态都抽象成一个类，并且实现每个类下的功能性函数，
就能够在需要对状态进行变更的时候做到影响最小，可维护性增加。

所以，状态模式其本质是优化条件分支下的不同策略的一种模式。

## 备忘录模式 Memento Pattern

如果用副本模式描述会更加贴切。
和原型模式类似，但是备忘录模式能够，将从某一状态克隆出来的对象（只读）当做副本操作，并把操作后的状态再
恢复到原本的对象中。

备忘录模式下需要注意的问题，如果有多个使用者需要使用对象的备忘，那么我们就要自己处理可能产生状态冲突的逻辑。

## 中介者模式 Mediator Pattern 行为模式

描述中介者最直观的例子就是交换机与客户端。
这里的交换机就是中介者模式的`中介者`，客户端就是中介者模式中的`同事类`。

为什么使用中介者模式，就是为了降低不同对象之间互相调用的复杂度。
通过中介者解耦，本质也是通过消息的解耦。中介者其实有点类似于注册中心，
因为他需要知道所有参与中介化调用的对象主体。

核心抽象类和抽象方法如下：
```
class Colleague {
    function sendMsg()
    function receiveMsg()
}

// 中介者的必要条件
class Mediator {
    ColleagueList array()
    function register()
    function operation()
}
```

中介者模式已经将方法的调用，抽象成了消息的收发，所以他是及其像微服务架构中的
注册中心，以及负责注册中心的消息队列的。


## 观察者模式 Visitor Pattern 行为模式

观察者模式，可以简单总结为对消息的监听。多个对象，监听某个目标对象的状态，一旦目标对象状态发生改变，监听对象也会随之变化。
观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。

这个模式的核心是一个观察目标（主题）与多个观察者。
最基本的观察者模式并像我们的消息队列一样，至少由三个角色构成，暨消息发送者-消息中间件-消息消费者。
而是只要两个角色主题对象-主题订阅者对象。

从代码的层面，需要有：
```
class Subject {
    objList array()
    state // 主题状态，监听的对象
    attach() // 主题添加观察者
    detach() // 主题删除观察者
    notify() // 遍历通知观察者
}

class Observer {
    observerState
    function update()
}
```
以及他们的实现。
我们可以看到，对于主题来说，还是需要维护一个监听者列表。
在通知的时候也是循环遍历这个列表并予以通知。

不过对于与这个主题绑定的被监听者来说，他并不需要知道多少监听者在监听他，
这一设计思想其实也是观察者模式所带来的一个亮点。


## 迭代器模式 Iterator Pattern 行为模式

为什么要用迭代器模式？
说白了就是将不同的数据结构的对象，用一个同样的接口给包装起来。
这样，其他调用者就可以很方便遍历这个数据结构。
他解决的是数据对象和数据遍历方式之间的优化。

最简单的需要实现的就是数据的上一个，下一个。
通常迭代器模式中的迭代器是一次性的，一轮以后再次迭代将获取不到元素。

但是其实可以做衍生扩展，比如python中，就会有好几种迭代器以满足不同的需求。
- 无限迭代器
- 有限迭代器
- 组合迭代器


## 解释器模式 Interpreter Pattern 行为模式

解释器模式将每一种行为，或者操作具现化成一个类，
每个类都会有一个解释函数，用来解释这个行为的具体操作。

```
abstract class Expression {
    function inter()
}

class Add {
    a
    b
    function inter()
}

class Sub() {
    a
    b
    function inter()
}

...
```

解释器模式最常用的场景就是 sql的处理，比如orm中的sql链式函数调用。就可以用到解释器的模式。
解释器模式更像是自己实现一套领域语法函数，缺点是因为把一个行为作为一个类，所以当对象的行为增加时，
难免会造成维护困难。
据说这个模式是用得最少的，因为要对自己实现的文法对象了如指掌，因为维护上的困难也并不推荐大家使用。

